head     1.1;
access   ;
symbols  ;
locks    ;comment  @@;


1.1
date     2021.05.11.11.42.05;  author p4;  state Exp;
branches ;
next     ;


desc
@@


1.1
log
@@
text
@using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System;

public class AVL : TreeBuilder
{
    // extends the TreeNode class by adding AVL elements
    // NOTES: AVLNode.children is inherited but 
    protected class AVLNode : TreeNode{
        public short balanceFactor;
        public int height;
        public AVLNode(int value, int depth, int NoOfChildren) : base(value, depth, NoOfChildren){
            balanceFactor = 0;
            height = 1;
        }
    }
    
    // Start is called before the first frame update
    void Start()
    {
        depth = 0;
        size = 20;
        // set the root node
        root = new AVLNode(r.Next(100),0, 2);
        Debug.Log(root.GetType());
        q.Enqueue(new QueueCommand(0, root, null, 0));
        // set all the other nodes
        for (int i = 0; i < size; i++){
            root = addNode((AVLNode)root, null, r.Next(100), 0);
            q.Enqueue(new QueueCommand(6, null, null, 0));
        }     
        StartCoroutine(readQueue(.5f));        
    }
    // add a node to the tree
    // recursively call the function until we hit the point it gets added
    protected AVLNode addNode(AVLNode root, AVLNode parent, int x, int depth){
        // build the node and its line renderer
        if (root == null){
            // increment deepest depth
            if(depth > this.depth){
                this.depth = depth;
                setCam();
            }
            AVLNode node = new AVLNode(x, depth, 2);
            q.Enqueue(new QueueCommand(0, node, null, 0));
            q.Enqueue(new QueueCommand(3, node, parent, 0));

            return node;
        }
        else{
            q.Enqueue(new QueueCommand(1, root, null, 0));
            if (x < root.value){
                q.Enqueue(new QueueCommand(4, root, null, 0));

                root.children[0] = addNode((AVLNode)(root.children[0]), root, x, depth + 1);
                if (root.children[1] ==  null){
                    root.balanceFactor = 1;
                }
                else{
                    root.balanceFactor = (short)((AVLNode)(root.children[0]).height - (AVLNode)(root.children[1]).height);
                }
                root.childEdges[0] = root.children[0].parentEdge;

            }
            else{
                q.Enqueue(new QueueCommand(4, root, null, 1));

                if (root.children[0] ==  null){
                    root.balanceFactor = 1;
                }
                else{
                    root.balanceFactor = (short)(root.children[0].height - root.children[1].height);
                }
                root.childEdges[1] = root.children[1].parentEdge;
            }
            q.Enqueue(new QueueCommand(2, root, null, 0));
            if (Math.Abs(root.balanceFactor) > 1){
                
            }
            return root;
        }
    }

    // Update is called once per frame
    void Update()
    {
        
    }
}
@
